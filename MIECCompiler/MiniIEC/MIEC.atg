
#include <wchar.h>
#include "SymbolTable.h"
#include "DACGenerator.h"

COMPILER MIEC

	BaseType* mInteger;

	SymbolTable* pList;
	DACGenerator* pDACGen;

	void Err(wchar_t* msg) {
		errors->Error(la->line, la->col, msg);
	}

CHARACTERS
	letter = 'A'..'Z' + 'a'..'z'.
	digit = "0123456789".
	cr  = '\r'.
	lf  = '\n'.
	tab = '\t'.
TOKENS
	ident  = letter {letter | digit}.
	number = digit {digit}.
  
    
COMMENTS
	FROM "(*" TO "*)" NESTED

IGNORE cr + lf + tab
   
PRODUCTIONS

MIEC
	= "PROGRAM" ident
		[VarDecl]
	  "BEGIN"
		Statements
	  "END"
	.

VarDecl									(. mInteger = new BaseType(BaseType::eInt); .)
	= "BEGIN_VAR"						(. wchar_t* name; BaseType* type; size_t addr = 0; .)
	  Ident<name> ":" Type<type> ";"	(. pList->AddSymbol(new VarSym(type, name, addr)); addr += type->GetSize(); .)
	{ Ident<name> ":" Type<type> ";"	(. if (pList->FindSymbol(name) == 0) {pList->AddSymbol(new VarSym(type, name, addr)); addr += type->GetSize();} else Err(L"VarDecl: ident already defined"); .)
	}
	  "END_VAR"
	.

Statements 
	= Stat 
	{ Stat }
	.

Stat									(. Symbol* pSym; .)
	= Assignment<pSym> ";"
	| "print" "(" Expr<pSym> ")" ";"
	| "WHILE" Condition "DO" Statements "END"
	| "IF" Condition "THEN" Statements ["ELSE" Statements] "END"
	.

Assignment<Symbol* &pSym>				(. wchar_t* name; Symbol* pSym1; .)
	= Ident<name>						(. pSym = pList->FindSymbol(name); if (pSym == 0) {Err(L"Assignment: undeclared ident"); return;} .)
	  ":="
	  Expr<pSym1>						(. if (pSym1 == 0) return; .)
										(. if (pSym->GetType() != pSym1->GetType()) {Err(L"Assignment: incompatible types"); return;} .)
	.

Condition								(. Symbol* pSym; Symbol* pSym1; .)
	= Expr<pSym> Relop Expr<pSym1>		(. /* TODO: check type =?= type1 */ .)
	.

Expr<Symbol* &pSym>						(. DACSymbol::OpKind op; Symbol* pSym1; .)
	= Term<pSym>						(. if (pSym == 0) return; .)
	{ ( "+"								(. op = DACSymbol::eAdd; .)
	  | "-"								(. op = DACSymbol::eSubtract; .)
	  )
	  Term<pSym1>						(. if (pSym == 0) return; .)
										(. if (pSym->GetType() != pSym1->GetType()) {Err(L"Expr: incompatible types"); return;}
											pSym = pList->AddSymbol(pDACGen->AddStat(op, pSym, pSym1)); .)
	}
	.

Term<Symbol* &pSym>					(. DACSymbol::OpKind op; Symbol* pSym1; .)
	= Fact<pSym>						(. if (pSym == 0) return; .)
	{ ( "*"								(. op = DACSymbol::eMultiply; .)
	  | "/"								(. op = DACSymbol::eDivide; .)
	  )
	  Fact<pSym1>						(. if (pSym == 0) return; .)
										(. if (pSym->GetType() != pSym1->GetType()) {Err(L"Term: incompatible types"); return;}
											pSym = pList->AddSymbol(pDACGen->AddStat(op, pSym, pSym1)); .)
	}
	.

Fact<Symbol* &pSym>						(. wchar_t* name; int val; .)
	= Ident<name>						(. pSym = pList->FindSymbol(name); if (pSym == 0) {Err(L"Fact: undeclared ident"); return;} .)
	| Number<name, val>					(. pSym = pList->AddSymbol(new ConstSym(mInteger, name, val)); .)
	| "(" Expr<pSym> ")"
	.

Relop 
	= "="
	| "<="
	| ">="
	| "!="
	| "<"
	| ">"
	.

Type<BaseType* &type>
	= "Integer"							(. type = mInteger; .)
	.

Ident<wchar_t* &name>
	= ident								(. name = t->val; .)
	.

Number<wchar_t* &name, int &val>
	= number							(. name = t->val; swscanf(t->val, L"%d", &val); .)
	.

END MIEC .