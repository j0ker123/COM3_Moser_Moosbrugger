
#include <wchar.h>
#include "DACGenerator.h"

COMPILER MIEC

	DACGenerator* pDACGen;

CHARACTERS
	letter = 'A'..'Z' + 'a'..'z' .
	digit = "0123456789" .
	cr  = '\r' .
	lf  = '\n' .
	tab = '\t' .

TOKENS
	ident = letter {letter | digit} .
	number = digit {digit} .

COMMENTS
	FROM "(*" TO "*)" NESTED

IGNORE cr + lf + tab

PRODUCTIONS

MIEC
	= "PROGRAM" ident					(. pDACGen = new MIEC::DACGenerator(this); .)
		[ VarDecl ]
	  "BEGIN"
		Statements
	  "END"								(. pDACGen->AddStat(DACSymbol::eExit, 0, 0); .)
	.

VarDecl
	= "BEGIN_VAR"						(. wchar_t* pName; DataType* pType; size_t addr = 0; .)
	  Ident<pName> ":" Type<pType> ";"	(. pDACGen->AddSymbol(new VarSym(pType, pName, addr)); addr += pType->GetSize(); .)
	{ Ident<pName> ":" Type<pType> ";"	(. pDACGen->AddSymbol(new VarSym(pType, pName, addr)); addr += pType->GetSize(); .)
	}
	  "END_VAR"
	.

Statements
	= Stat
	{ Stat
	}
	.

Stat									(. Symbol* pSym = 0; .)
	= Assignment<pSym>
	| Branch<pSym>
	| Loop<pSym>
	| Print<pSym>
	.

Assignment<Symbol* &pSym>				(. wchar_t* pName; Symbol* pSym1 = 0; .)
	= Ident<pName>						(. pSym = pDACGen->GetSymbol(pName); .)
	  ":="
	  Expr<pSym1> ";"					(. pSym = pDACGen->AddStat(DACSymbol::eAssign, pSym, pSym1); .)
	.

Branch<Symbol* &pSym>					(. DACLabel* pLblElse = pDACGen->GetNewLabel(); DACLabel* pLblNext = pDACGen->GetNewLabel(); .)
	= "IF"
	  Condition<pSym>
	  "THEN"							(. pDACGen->AddStat(DACSymbol::eIfFalseJump, pSym, pLblElse); .)
	  Statements
	  [ "ELSE"							(. pDACGen->AddStat(DACSymbol::eJump, pLblNext, 0); pDACGen->AddLabel(pLblElse); .)
	    Statements						(. pDACGen->AddLabel(pLblNext); .)
	  ]
	  "END"								(. pDACGen->AddLabel(pLblElse); .)
	.

Loop<Symbol* &pSym>						(. DACLabel* pLblCond = pDACGen->GetNewLabel(); DACLabel* pLblNext = pDACGen->GetNewLabel(); .)
	= "WHILE"							(. pDACGen->AddLabel(pLblCond); .)
	  Condition<pSym>
	  "DO"								(. pDACGen->AddStat(DACSymbol::eIfFalseJump, pSym, pLblNext); .)
	  Statements						(. pDACGen->AddStat(DACSymbol::eJump, pLblCond, 0); .)
	  "END"								(. pDACGen->AddLabel(pLblNext); .)
	.

Print<Symbol* &pSym>
	= "print" "(" Expr<pSym> ")" ";"	(. pSym = pDACGen->AddStat(DACSymbol::ePrint, pSym, 0); .)
	.

Condition<Symbol* &pSym>				(. DACSymbol::OpKind op = DACSymbol::eUnknown; Symbol* pSym1 = 0; .)
	= Expr<pSym>
	  Relop<op>
	  Expr<pSym1>						(. pSym = pDACGen->AddStat(op, pSym, pSym1); .)
	.

Expr<Symbol* &pSym>						(. DACSymbol::OpKind op = DACSymbol::eUnknown; Symbol* pSym1 = 0; .)
	= Term<pSym>
	{ ( "+"								(. op = DACSymbol::eAdd; .)
	  | "-"								(. op = DACSymbol::eSubtract; .)
	  )
	  Term<pSym1>						(. pSym = pDACGen->AddStat(op, pSym, pSym1); .)
	}
	.

Term<Symbol* &pSym>						(. DACSymbol::OpKind op = DACSymbol::eUnknown; Symbol* pSym1 = 0; .)
	= Fact<pSym>
	{ ( "*"								(. op = DACSymbol::eMultiply; .)
	  | "/"								(. op = DACSymbol::eDivide; .)
	  )
	  Fact<pSym1>						(. pSym = pDACGen->AddStat(op, pSym, pSym1); .)
	}
	.

Fact<Symbol* &pSym>						(. wchar_t* pName; DataObject* pVal; pDACGen->SetLine(t->line); .)
	= Ident<pName>						(. pSym = pDACGen->GetSymbol(pName); .)
	| Number<pName, pVal>				(. pSym = pDACGen->AddSymbol(new ConstSym(pDACGen->AddType(new IntegerType()), pName, pVal)); .)
	| "(" Expr<pSym> ")"
	.

Relop<DACSymbol::OpKind &op>
	= "="								(. op = DACSymbol::eIsEqual; .)
	| "<="								(. op = DACSymbol::eIsLessEqual; .)
	| ">="								(. op = DACSymbol::eIsGreaterEqual; .)
	| "!="								(. op = DACSymbol::eIsNotEqual; .)
	| "<"								(. op = DACSymbol::eIsLess; .)
	| ">"								(. op = DACSymbol::eIsGreater; .)
	.

Type<DataType* &pType>
	= "Integer"							(. pType = pDACGen->AddType(new IntegerType()); .)
	.

Ident<wchar_t* &pName>
	= ident								(. pDACGen->SetLine(t->line); pName = t->val; .)
	.

Number<wchar_t* &pName, DataObject* &pVal>
	= number							(. pDACGen->SetLine(t->line); pName = t->val; int val; swscanf(t->val, L"%i", &val); pVal = new IntegerObject(val); .)
	.

END MIEC .
