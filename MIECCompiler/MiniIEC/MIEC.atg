
#include <wchar.h>
#include "SymbolTable.h"
#include "DACGenerator.h"

COMPILER MIEC

	enum eOp { eAdd, eSub, eMul, eDiv };

	BaseType* mInteger;

	SymbolTable mList;
	DACGenerator mDACGen;

	void Err(wchar_t* msg) {
		errors->Error(la->line, la->col, msg);
	}

CHARACTERS
	letter = 'A'..'Z' + 'a'..'z'.
	digit = "0123456789".
	cr  = '\r'.
	lf  = '\n'.
	tab = '\t'.
TOKENS
	ident  = letter {letter | digit}.
	number = digit {digit}.
  
    
COMMENTS
	FROM "(*" TO "*)" NESTED

IGNORE cr + lf + tab
   
PRODUCTIONS

MIEC 
	= "PROGRAM" ident
		[VarDecl]
	  "BEGIN"
		Statements
	  "END"
	.

VarDecl									(. mInteger = new BaseType(BaseType::eInt); .)
	= "BEGIN_VAR"						(. wchar_t* name; BaseType* type; size_t addr = 0; .)
	  Ident<name> ":" Type<type> ";"	(. mList.AddSymbol(new VarSym(type, name, addr), name); addr += type->GetSize(); .)
	{ Ident<name> ":" Type<type> ";"	(. mList.AddSymbol(new VarSym(type, name, addr), name); addr += type->GetSize(); .)
	}
	  "END_VAR"
	.

Statements 
	= Stat 
	{ Stat }
	.

Stat									(. SymbolType* type; .)
	= Assignment<type> ";"
	| "print" "(" Expr<type> ")" ";"
	| "WHILE" Condition "DO" Statements "END"
	| "IF" Condition "THEN" Statements ["ELSE" Statements] "END"
	.

Assignment<SymbolType* &type>			(. Symbol* pSym; wchar_t* name; .)
	= Ident<name>						(. pSym = mList.FindSymbol(name); if (pSym == 0) {Err(wcscat(L"Assignment: undeclared ident", name)); return;} .)
	  ":="
	  Expr<type>						(. if (type != pSym->GetType()) {Err(L"Assignment: incompatible types"); return;} .)
	.

Condition								(. SymbolType* type; SymbolType* type1; .)
	= Expr<type> Relop Expr<type1>		(. /* TODO: check type =?= type1 */ .)
	.

Expr<SymbolType* &type>					(. SymbolType* type1; .)
	= Term<type>						
	{ ( "+"								(. eOp op = eAdd; .)
	  | "-"								(. eOp op = eSub; .)
	  )
	  Term<type1>						(. if (type != type1) Err(L"Expr: incompatible types"); return; .)
	}
	.

Term<SymbolType* &type>					(. SymbolType* type1; .)
	= Fact<type> 
	{ ( "*"								(. eOp op = eMul; .)
	  | "/"								(. eOp op = eDiv; .)
	  )
	  Fact<type1>						(. if (type != type1) Err(L"Term: incompatible types"); return; .)
	}
	.

Fact<SymbolType* &type>					(. Symbol* pSym; wchar_t* name; int val; .)
	= Ident<name>						(. pSym = mList.FindSymbol(name); if (pSym == 0) {Err(L"Fact: undeclared ident"); return;} type = pSym->GetType(); .)
	| Number<name, val>					(. type = mInteger; pSym = mList.AddSymbol(new ConstSym(type, name, val), name); .)
	| "(" Expr<type> ")"
	.

Relop 
	= "="
	| "<="
	| ">="
	| "!="
	| "<"
	| ">"
	.

Type<BaseType* &type>
	= "Integer"							(. type = mInteger; .)
	.

Ident<wchar_t* &name>
	= ident								(. name = t->val; .)
	.

Number<wchar_t* &name, int &val>
	= number							(. name = t->val; swscanf(t->val, L"%d", &val); .)
	.

END MIEC .