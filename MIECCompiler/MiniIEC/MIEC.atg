
#include <wchar.h>
#include "SymbolTable.h"
#include "DACGenerator.h"

COMPILER MIEC

	BaseType* mInteger;

	SymbolTable* pList;
	DACGenerator* pDACGen;

	void Err(wchar_t* msg) {
		errors->Error(la->line, la->col, msg);
	}

CHARACTERS
	letter = 'A'..'Z' + 'a'..'z'.
	digit = "0123456789".
	cr  = '\r'.
	lf  = '\n'.
	tab = '\t'.
TOKENS
	ident  = letter {letter | digit}.
	number = digit {digit}.
  
    
COMMENTS
	FROM "(*" TO "*)" NESTED

IGNORE cr + lf + tab
   
PRODUCTIONS

MIEC
	= "PROGRAM" ident
		[ VarDecl ]
	  "BEGIN"
		Statements
	  "END"
	.

VarDecl									(. mInteger = new BaseType(BaseType::eInt); .)
	= "BEGIN_VAR"						(. wchar_t* name; BaseType* type; size_t addr = 0; .)
	  Ident<name> ":" Type<type> ";"	(. pList->AddSymbol(new VarSym(type, name, addr)); addr += type->GetSize(); .)
	{ Ident<name> ":" Type<type> ";"	(. /*if (pList->FindSymbol(name) == 0) {*/pList->AddSymbol(new VarSym(type, name, addr)); addr += type->GetSize();/*} else Err(L"VarDecl: ident already defined");*/ .)
	}
	  "END_VAR"
	.

Statements 
	= Stat 
	{ Stat }
	.

Stat									(. Symbol* pSym = 0; .)
	= Assignment<pSym>
	| Branch<pSym>
	| Loop<pSym>
	| Print<pSym>
	.

Assignment<Symbol* &pSym>				(. wchar_t* name; Symbol* pSym1 = 0; .)
	= Ident<name>						(. pSym = pList->FindSymbol(name); /*if (pSym == 0) Err(L"Assignment: undefined ident");*/ .)
	  ":=" 
	  Expr<pSym1> ";"					(. pSym = pList->AddSymbol(pDACGen->AddStat(DACSymbol::eAssign, pSym, pSym1)); .)
	.

Branch<Symbol* &pSym>					(. DACLabelSymbol* pLblElse = pDACGen->GetNewLabel(); DACLabelSymbol* pLblNext = pDACGen->GetNewLabel(); .)
	= "IF"								
	  Condition<pSym>					(. /*if (pSym == 0 /* TODO: || pSym->GetType() != boolean */) Err(L"Branch: invalid condition");*/ .)
	  "THEN"							(. pList->AddSymbol(pDACGen->AddStat(DACSymbol::eIfFalseJump, pSym, pLblElse)); .)
	  Statements						(. pList->AddSymbol(pDACGen->AddStat(DACSymbol::eJump, pLblNext, 0)); .)
	  [ "ELSE"							(. /* TODO: use pLblElse */ .)
	    Statements
	  ] 
	  "END"								(. /* TODO: use pLblNext */ .)
	.

Loop<Symbol* &pSym>						(. DACLabelSymbol* pLblCond = pDACGen->GetNewLabel(); DACLabelSymbol* pLblNext = pDACGen->GetNewLabel(); .)
	= "WHILE"							(. /* TODO: use pLblCond */ .)
	  Condition<pSym>					(. if (pSym == 0 /* TODO: || pSym->GetType() != boolean */) Err(L"Loop: invalid condition"); .)
	  "DO"								(. pList->AddSymbol(pDACGen->AddStat(DACSymbol::eIfFalseJump, pSym, pLblNext)); .)
	  Statements						(. pList->AddSymbol(pDACGen->AddStat(DACSymbol::eJump, pLblCond, 0)); .)
	  "END"								(. /* TODO: use pLblNext */ .)
	.

Print<Symbol* &pSym>
	= "print" "(" Expr<pSym> ")" ";"	(. pSym = pList->AddSymbol(pDACGen->AddStat(DACSymbol::ePrint, pSym, 0)); .)
	.

Condition<Symbol* &pSym>				(. DACSymbol::OpKind op = DACSymbol::eUnknown; Symbol* pSym1 = 0; .)
	= Expr<pSym> Relop<op> Expr<pSym1>	(. pSym = pList->AddSymbol(pDACGen->AddStat(op, pSym, pSym1)); .)
	.

Expr<Symbol* &pSym>						(. DACSymbol::OpKind op = DACSymbol::eUnknown; Symbol* pSym1 = 0; .)
	= Term<pSym>						(. /*if (pSym == 0) Err(L"Expr: invalid term");*/ .)
	{ ( "+"								(. op = DACSymbol::eAdd; .)
	  | "-"								(. op = DACSymbol::eSubtract; .)
	  )
	  Term<pSym1>						(. pSym = pList->AddSymbol(pDACGen->AddStat(op, pSym, pSym1)); .)
	}
	.

Term<Symbol* &pSym>						(. DACSymbol::OpKind op = DACSymbol::eUnknown; Symbol* pSym1 = 0; .)
	= Fact<pSym>						(. /*if (pSym == 0) Err(L"Term: invalid fact");*/ .)
	{ ( "*"								(. op = DACSymbol::eMultiply; .)
	  | "/"								(. op = DACSymbol::eDivide; .)
	  )
	  Fact<pSym1>						(. pSym = pList->AddSymbol(pDACGen->AddStat(op, pSym, pSym1)); .)
	}
	.

Fact<Symbol* &pSym>						(. wchar_t* name; int val; .)
	= Ident<name>						(. pSym = pList->FindSymbol(name); /*if (pSym == 0) Err(L"Fact: undefined ident");*/ .)
	| Number<name, val>					(. pSym = pList->AddSymbol(new ConstSym(mInteger, name, val)); .)
	| "(" Expr<pSym> ")"
	.

Relop<DACSymbol::OpKind &op>
	= "="								(. op = DACSymbol::eIsEqual; .)
	| "<="								(. op = DACSymbol::eIsLessEqual; .)
	| ">="								(. op = DACSymbol::eIsGreaterEqual; .)
	| "!="								(. op = DACSymbol::eIsNotEqual; .)
	| "<"								(. op = DACSymbol::eIsLess; .)
	| ">"								(. op = DACSymbol::eIsGreater; .)
	.

Type<BaseType* &type>
	= "Integer"							(. type = mInteger; .)
	.

Ident<wchar_t* &name>
	= ident								(. name = t->val; .)
	.

Number<wchar_t* &name, int &val>
	= number							(. name = t->val; swscanf(t->val, L"%d", &val); .)
	.

END MIEC .